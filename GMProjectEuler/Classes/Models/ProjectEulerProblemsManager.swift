//
//  ProjectEulerProblemsManager.swift
//  GMProjectEuler
//
//  Created by Mustafa on 16/01/2015.
//  Copyright (c) 2015 Learning. All rights reserved.
//

import Foundation

class ProjectEulerProblemsManager {
    
    // MARK: - Singleton
    
    struct Static {
        static var onceToken : dispatch_once_t = 0
        static var instance : ProjectEulerProblemsManager? = nil
    }

    class var sharedManager : ProjectEulerProblemsManager {
        
        dispatch_once(&Static.onceToken) {
            Static.instance = ProjectEulerProblemsManager()
        }
        
        return Static.instance!
    }
    
    // MARK: - Initialization
    
    var problems:[Problem] = []
    
    init () {
        loadProblems();
    }
    
    func loadProblems() {
        let filePathFromBundle = NSBundle.mainBundle().pathForResource("ProjectEulerProblems", ofType:"plist")
        let manager = NSFileManager.defaultManager()
        
        if (manager.fileExistsAtPath(filePathFromBundle!)) {
            let plistArray = NSArray(contentsOfFile: filePathFromBundle!)

            // Developer's Note: We want to work with swift's array and dictionary objects instead of foundation array and dictionary i.e. NSArray and NSDictionary
            // So we're type casting foundation array to swift array and working with those.
            let swiftArray = plistArray as [NSDictionary]
            var objectsArray:[Problem] = []

            for swiftDictionary in swiftArray {
                var number: String = swiftDictionary["number"] as String
                var title: String = swiftDictionary["title"] as String
                var detail: String = swiftDictionary["detail"] as String
                var reference: String = swiftDictionary["reference"] as String
                var status: String = swiftDictionary["status"] as String
                
                var aProblem: Problem = Problem(n: number.toInt()!, t: title, d: detail, r: reference, s: status)
                objectsArray.append(aProblem)
            }
            
            self.problems = objectsArray

        } else {
            println("File doesn't exist at the specified path: \(filePathFromBundle)")
        }
    }
    
    // MARK: - Public methods
    
    func solveProblem(problem: Problem) -> String {
        var result: String?
        let start: NSDate = NSDate();

        switch (problem.number) {
        case 1:
            result = solveProblem001()
        case 2:
            result = solveProblem002()
        case 3:
            result = solveProblem003()
        case 4:
            result = solveProblem004()
        case 5:
            result = solveProblem005()
        case 6:
            result = solveProblem006()
        case 7:
            result = solveProblem007()
        case 8:
            result = solveProblem008()
        case 9:
            result = solveProblem009()
        case 10:
            result = solveProblem010()
        case 11:
            result = solveProblem011()
        case 12:
            result = solveProblem012()
        case 13:
            result = solveProblem013()
        case 14:
            result = solveProblem014()
        case 15:
            result = solveProblem015()
        case 16:
            result = solveProblem016()
        case 17:
            result = solveProblem017()
        case 18:
            result = solveProblem018()
        case 19:
            result = solveProblem019()
        case 20:
            result = solveProblem020()
        default:
            result = ""
        }
        
        let end: NSDate = NSDate()
        let timeInterval: NSTimeInterval = end.timeIntervalSinceDate(start);
        println("Time to evaluate problem \(problem.number): " + String(format: "%.6f", timeInterval) + " seconds");

        result = result! + "\n\n" + "[Time Elapsed: " + String(format: "%.6f", timeInterval) + " seconds]"
        return result!
    }
    
    // MARK: Public (wrapper) methods
    
    func solveProblem001() -> String {
        //Multiples of 3 and 5
        //
        //If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        //Find the sum of all the multiples of 3 or 5 below 1000.
        //
        //Solved by: GM
        
        var sum: Int = 0
        
        for naturalNumber in 0..<1000 {
            
            if (naturalNumber % 3 == 0) || (naturalNumber % 5 == 0) {
                sum += naturalNumber
            }
        }

        // Result
        let formattedResult = formattedNumberString(sum)
        var result = "The sum of all the multiples of 3 or 5, below 1000 is:\n\n\(formattedResult)"
        
        return result
    }

    func solveProblem002() -> String {
        //Even Fibonacci numbers
        //
        //Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
        //1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        //By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
        //
        //Solved by: GM

        var fibonnaciSequence: [Int] = []
        
        var secondLastFibbonacciNumber: Int = 1
        var lastFibbonacciNumber: Int = 2
        var fibbonacciNumber: Int = 0
        
        var sum: Int = 0 + lastFibbonacciNumber
        var limit: Int = 4000000
        
        fibonnaciSequence.append(secondLastFibbonacciNumber)
        fibonnaciSequence.append(lastFibbonacciNumber)
        
        while (fibbonacciNumber < limit) {
            fibbonacciNumber = secondLastFibbonacciNumber + lastFibbonacciNumber
            secondLastFibbonacciNumber = lastFibbonacciNumber
            lastFibbonacciNumber = fibbonacciNumber
            
            if (fibbonacciNumber < limit) {
                fibonnaciSequence.append(fibbonacciNumber)

                if (fibbonacciNumber % 2 == 0) {
                    sum += fibbonacciNumber
                }
            }
        }
        
        // Printing sequence
        println("Fibbonnaci Sequence:")
        var index: Int = 0
        var total: Int = fibonnaciSequence.count
        
        for index = 0; index < total; index++ {
            print("\(fibonnaciSequence[index])")
            
            if (index != fibonnaciSequence.count - 1) {
                print(",")
            }
        }
        
        // Result
        let formattedResult = formattedNumberString(sum)
        var result = "The sum of the even-valued Fibonacci terms is:\n\n\(formattedResult)"
        
        return result
    }

    func solveProblem003() -> String {
        // Largest prime factor
        // The prime factors of 13195 are 5, 7, 13 and 29.
        // What is the largest prime factor of the number 600851475143?
        //
        //Solved by: SM
        //Solution Note: Implemented algo from following link for fast computation
        //http://stackoverflow.com/questions/23287/largest-prime-factor-of-a-number/23013770#23013770
        
        let num:Int = 600851475143
        var n:Int = num
        var i:Int = 2
        var test:Int = 0
        var maxPrimeFactor:Int = 2
        
        while (n > 1) {
            
            while (n % i == 0) {
                n = n/i
            }
            
            i++
            
            if (i*i > n && n > 1) {
                maxPrimeFactor = n
                test = 1
                break
            }
        }
        
        if (test == 0) {
            maxPrimeFactor = i-1
        }
        
        // Result
        let formattedResult = formattedNumberString(maxPrimeFactor)
        var result = "The largest prime factor of the number 600,851,475,143 is:\n\n\(formattedResult)"
        
        return result
    }
    
    func solveProblem003__deprecated_2015_02_11() -> String {
        //Largest prime factor
        //
        //The prime factors of 13195 are 5, 7, 13 and 29.
        //What is the largest prime factor of the number 600851475143?
        //
        //Solved by: GM
        //Solution Note: This solution is _extremely_ slow!
        
        var theNumber: Int = 600851475143
        var primeFactors: [Int] = []
        
        // Loop to find all prime factors of the number
        var number: Int = 0
        
        for number in 2..<(theNumber/2) {
            
            if isPrime(number) {
                [primeFactors.append(number)]
            }
        }
        
        // Find the largest prime factor
        var largestPrime: Int = -1;
        var index: Int = primeFactors.count

        for primeNumber in primeFactors.reverse() {

            if (theNumber%primeNumber == 0) {
                largestPrime = primeNumber
                break;
            }
        }
        
        // Result
        let formattedResult = formattedNumberString(largestPrime)
        var result = "The largest prime factor of the number 600,851,475,143 is:\n\n\(formattedResult)"

        return result
    }
    
    func solveProblem004() -> String {
        //Largest palindrome product
        //
        //A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
        //Find the largest palindrome made from the product of two 3-digit numbers.
        //
        //Solved by: SM

        var i:Int
        var j:Int
        
        var n:Int
        var numberInString:String
        
        var p:Bool
        var found:Bool = false
        
        var n1:Int = 0
        var n2:Int = 0
        var maxProduct:Int = 0
        
        for i = 999; i >= 100 && !found; i-- {
            
            for j = 999; j >= 100 && !found; j-- {
                
                // Taking product of 3-digit numbers
                n = i * j
                
                // Converting int to string to get number of digits
                numberInString = toString(n)
                
                p = isPalindrome(numberInString)
                
                // Palindrome number found!!!
                // Developer's Note : brk is used to break out of nested for loops
                if (p) {
                    n1 = i
                    n2 = j
                    maxProduct = n
                    found = true
                    break
                }
            }
        }
        
        var result = "The largest palindrome made from the product of two 3-digit numbers is \(maxProduct) = \(n1) × \(n2)"
        return result
    }
    
    func solveProblem005() -> String {
        //Smallest multiple
        //
        //2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
        //What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
        //
        //Solved by: SM

        var num:Int = 400
        var c:Bool = true
        
        while (c) {
            
            // Check divisibility by prime numbers : 19, 17, 13, 11
            // Divisible by 18 => Divisibility by 9, 6, 3 and 2
            // Divisible by 16 => Divisibility by 8, 4 and 2
            // Divisible by 14 => Divisibility by 7 and 2
            // Divisible by 10 => Divisibility by 10 and 5
            
            // ============ (NO NEED TO CHECK - ALREADY CHECKED) =============
            // Divisible by 15 => Divisibility by 5 and 3
            // Divisible by 12 => Divisibility by 6, 4, 3 and 2
            
            if ((num % 19 == 0) && (num % 18 == 0) && (num % 17 == 0) && (num % 16 == 0) && (num % 14 == 0) && (num % 13 == 0) && (num % 11 == 0) && (num % 10 == 0)) {
                c = false
                
            } else {
                
                // Adding 10 because it should be divisible by 10
                num += 10
            }
        }
        
        var result = "Smallest positive number that is evenly divisible by all of the numbers from 1 to 20 is : \(num)"
        return result
    }

    func solveProblem006() -> String {
        //Sum square difference
        //
        //The sum of the squares of the first ten natural numbers is,
        //1^2 + 2^2 + ... + 10^2 = 385
        //
        //The square of the sum of the first ten natural numbers is,
        //(1 + 2 + ... + 10)^2 = 552 = 3025
        //
        //Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
        //Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
        //
        //Solved by: SM

        var i:Int = 1
        var sumOfSquares:Int = 0
        var sum:Int = 0
        
        for i = 1; i <= 100; i++ {
            sum += i
            sumOfSquares += (i*i)
        }
        
        let squareOfSum:Int = sum * sum
        let diff:Int = squareOfSum - sumOfSquares
        
        var result = "Difference between the sum of the squares of the first one hundred natural numbers and the square of the sum is \(squareOfSum) - \(sumOfSquares) = \(diff)"
        return result
    }

    func solveProblem007() -> String {
        //10001st prime
        //
        //By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
        //What is the 10 001st prime number?
        //
        //Solved by: SM

        let endIndex:Int = 10001
        var c:Bool = true
        
        var num:Int = 2
        var currentIndex:Int = 0
        
        while (c) {
            if (isPrime(num)) {
                currentIndex += 1
            }
            
            if (currentIndex == endIndex) {
                break;
            }
            
            num += 1
        }
        
        var result = "\(endIndex)st prime number is \(num)"
        return result
    }

    func solveProblem008() -> String {
        //Largest product in a series
        //
        //The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
        //
        //73167176531330624919225119674426574742355349194934
        //96983520312774506326239578318016984801869478851843
        //85861560789112949495459501737958331952853208805511
        //12540698747158523863050715693290963295227443043557
        //66896648950445244523161731856403098711121722383113
        //62229893423380308135336276614282806444486645238749
        //30358907296290491560440772390713810515859307960866
        //70172427121883998797908792274921901699720888093776
        //65727333001053367881220235421809751254540594752243
        //52584907711670556013604839586446706324415722155397
        //53697817977846174064955149290862569321978468622482
        //83972241375657056057490261407972968652414535100474
        //82166370484403199890008895243450658541227588666881
        //16427171479924442928230863465674813919123162824586
        //17866458359124566529476545682848912883142607690042
        //24219022671055626321111109370544217506941658960408
        //07198403850962455444362981230987879927244284909188
        //84580156166097919133875499200524063689912560717606
        //05886116467109405077541002256983155200055935729725
        //71636269561882670428252483600823257530420752963450
        //
        //Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
        //
        //Solved by: SM

        var numString:String = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
        
        var index:Int = 0
        var maxProduct:Int = 0
        var consNum:Int = 0
        
        var maxStringLength:Int = countElements(numString)
        let numberOfConsecutiveCharacters:Int = 13
        
        for index = 0; index <= maxStringLength - numberOfConsecutiveCharacters; index++ {
            let startIndex = advance(numString.startIndex, index)
            let endIndex = advance(numString.startIndex, index+numberOfConsecutiveCharacters)
            
            var subString:String  = numString[Range(start: startIndex, end: endIndex)]
            let numFromString:Int = subString.toInt()!
            
            let num:Int = productOfDigitsOfNumber(numFromString)
            
            if (num > maxProduct) {
                maxProduct = num
                consNum = numFromString
            }
        }
        
        var result = "Max Product of \(numberOfConsecutiveCharacters) consectutive numbers (\(consNum)) is \(maxProduct)"
        return result
    }

    func solveProblem009() -> String {
        //Special Pythagorean triplet
        //
        //A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
        //a2 + b2 = c2
        //
        //For example, 32 + 42 = 9 + 16 = 25 = 52.
        //There exists exactly one Pythagorean triplet for which a + b + c = 1000.
        //
        //Find the product abc.
        //
        //Solved by: SM

        var a:Float = 1
        var b:Float = 1
        var c:Float = 1
        
        var aVal:Int = 1
        var bVal:Int = 1
        var cVal:Int = 1
        
        var brk:Bool = false // Used to break out of nested loops
        
        for a = 1; a <= 1000; a++ {
            
            for b = 1; b <= 1000; b++ {
                
                for c = 1; c <= 1000; c++ {
                    
                    if (a + b + c == 1000 && pow(a, 2) + pow(b, 2) == pow(c, 2)) {
                        aVal = Int(a)
                        bVal = Int(b)
                        cVal = Int(c)
                        
                        brk = true
                        break
                    }
                }
                
                if (brk) {
                    break
                }
            }
            
            if (brk) {
                break
            }
        }
        
        var result = "Pythagorean triplet whose sum is equal to 1000 is (\(aVal), \(bVal), \(cVal))"
        return result
    }

    func solveProblem010() -> String {
        //Summation of primes
        //
        //The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
        //Find the sum of all the primes below two million.
        //
        //Solved by: SM
        
        let end:Int = 2000000
        var index:Int = 2

        var sum:Int = 0
        
        for index = 2; index < end; index++ {
            if (isPrime(index)) {
                sum += index
            }
        }
        
        var result = "Sum of primes below \(end) is \(sum)"
        return result
    }
    
    func solveProblem011() -> String {
        //Largest product in a grid
        //
        //In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
        //
        //08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
        //49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
        //81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
        //52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
        //22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
        //24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
        //32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
        //67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
        //24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
        //21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
        //78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
        //16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
        //86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
        //19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
        //04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
        //88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
        //04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
        //20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
        //20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
        //01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
        //The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
        //
        //What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
        //
        //Solved by: SM
        
        var grid: [[Int]] = [[08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08],
            [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00],
            [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65],
            [52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91],
            [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
            [24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
            [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
            [67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21],
            [24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
            [21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95],
            [78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92],
            [16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57],
            [86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
            [19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40],
            [04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
            [88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
            [04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36],
            [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16],
            [20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54],
            [01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]]
        
        let gridSize:Int = 20
        let checkConsecutiveNumbers:Int = 4
        
        var i:Int = 0
        var j:Int = 0
        
        var index:Int = 0
        
        var pivotVal:Int = 0
        var maxProduct:Int = 0
        
        var n1:Int = 0
        var n2:Int = 0
        var n3:Int = 0
        var n4:Int = 0
        
        for i = 0; i < gridSize; i++ {
            
            for j = 0; j < gridSize; j++ {
                
                pivotVal = grid[i][j]
                
                // Check left == Check right
                if (j - checkConsecutiveNumbers + 1 >= 0) {
                    
                    var counter:Int = 0
                    index = j
                    
                    var localProduct:Int = 1
                    
                    while (counter < checkConsecutiveNumbers) {
                        localProduct *= grid[i][index]
                        
                        index--
                        counter++
                    }
                    
                    if (localProduct > maxProduct) {
                        maxProduct = localProduct
                        
                        n1 = grid[i][index+1]
                        n2 = grid[i][index+2]
                        n3 = grid[i][index+3]
                        n4 = grid[i][index+4]
                    }
                }
                
                
                // Check up == Check down
                if (i - checkConsecutiveNumbers + 1 >= 0) {
                    
                    var counter:Int = 0
                    index = i
                    
                    var localProduct:Int = 1
                    
                    while (counter < checkConsecutiveNumbers) {
                        localProduct *= grid[index][j]
                        
                        index--
                        counter++
                    }
                    
                    if (localProduct > maxProduct) {
                        maxProduct = localProduct
                        
                        n1 = grid[index+1][j]
                        n2 = grid[index+2][j]
                        n3 = grid[index+3][j]
                        n4 = grid[index+4][j]
                    }
                }
                
                // Check diagonal
                if ((i + checkConsecutiveNumbers <= gridSize) && (j + checkConsecutiveNumbers <= gridSize)) {
                    
                    var counter:Int = 0
                    var firstIndex:Int = i
                    var secondIndex:Int = j
                    
                    var localProduct:Int = 1
                    
                    while (counter < checkConsecutiveNumbers) {
                        localProduct *= grid[firstIndex][secondIndex]
                        firstIndex++
                        secondIndex++
                        counter++
                    }
                    
                    if (localProduct > maxProduct) {
                        maxProduct = localProduct
                        
                        n1 = grid[firstIndex-1][secondIndex-1]
                        n2 = grid[firstIndex-2][secondIndex-2]
                        n3 = grid[firstIndex-3][secondIndex-3]
                        n4 = grid[firstIndex-4][secondIndex-4]
                    }
                }
            }
        }
        
        var result = "Max product of \(n1), \(n2), \(n3), and \(n4) is \(maxProduct)"
        return result
    }

    func solveProblem012() -> String {
        //Highly divisible triangular number
        //
        //The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
        //
        //1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        //
        //Let us list the factors of the first seven triangle numbers:
        //
        //1: 1
        //3: 1,3
        //6: 1,2,3,6
        //10: 1,2,5,10
        //15: 1,3,5,15
        //21: 1,3,7,21
        //28: 1,2,4,7,14,28
        //We can see that 28 is the first triangle number to have over five divisors.
        //
        //What is the value of the first triangle number to have over five hundred divisors?

        return "[Implementation Pending]"
    }

    func solveProblem013() -> String {
        //Large sum
        //
        //Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
        //
        //37107287533902102798797998220837590246510135740250
        //46376937677490009712648124896970078050417018260538
        //74324986199524741059474233309513058123726617309629
        //91942213363574161572522430563301811072406154908250
        //23067588207539346171171980310421047513778063246676
        //89261670696623633820136378418383684178734361726757
        //28112879812849979408065481931592621691275889832738
        //44274228917432520321923589422876796487670272189318
        //47451445736001306439091167216856844588711603153276
        //70386486105843025439939619828917593665686757934951
        //62176457141856560629502157223196586755079324193331
        //64906352462741904929101432445813822663347944758178
        //92575867718337217661963751590579239728245598838407
        //58203565325359399008402633568948830189458628227828
        //80181199384826282014278194139940567587151170094390
        //35398664372827112653829987240784473053190104293586
        //86515506006295864861532075273371959191420517255829
        //71693888707715466499115593487603532921714970056938
        //54370070576826684624621495650076471787294438377604
        //53282654108756828443191190634694037855217779295145
        //36123272525000296071075082563815656710885258350721
        //45876576172410976447339110607218265236877223636045
        //17423706905851860660448207621209813287860733969412
        //81142660418086830619328460811191061556940512689692
        //51934325451728388641918047049293215058642563049483
        //62467221648435076201727918039944693004732956340691
        //15732444386908125794514089057706229429197107928209
        //55037687525678773091862540744969844508330393682126
        //18336384825330154686196124348767681297534375946515
        //80386287592878490201521685554828717201219257766954
        //78182833757993103614740356856449095527097864797581
        //16726320100436897842553539920931837441497806860984
        //48403098129077791799088218795327364475675590848030
        //87086987551392711854517078544161852424320693150332
        //59959406895756536782107074926966537676326235447210
        //69793950679652694742597709739166693763042633987085
        //41052684708299085211399427365734116182760315001271
        //65378607361501080857009149939512557028198746004375
        //35829035317434717326932123578154982629742552737307
        //94953759765105305946966067683156574377167401875275
        //88902802571733229619176668713819931811048770190271
        //25267680276078003013678680992525463401061632866526
        //36270218540497705585629946580636237993140746255962
        //24074486908231174977792365466257246923322810917141
        //91430288197103288597806669760892938638285025333403
        //34413065578016127815921815005561868836468420090470
        //23053081172816430487623791969842487255036638784583
        //11487696932154902810424020138335124462181441773470
        //63783299490636259666498587618221225225512486764533
        //67720186971698544312419572409913959008952310058822
        //95548255300263520781532296796249481641953868218774
        //76085327132285723110424803456124867697064507995236
        //37774242535411291684276865538926205024910326572967
        //23701913275725675285653248258265463092207058596522
        //29798860272258331913126375147341994889534765745501
        //18495701454879288984856827726077713721403798879715
        //38298203783031473527721580348144513491373226651381
        //34829543829199918180278916522431027392251122869539
        //40957953066405232632538044100059654939159879593635
        //29746152185502371307642255121183693803580388584903
        //41698116222072977186158236678424689157993532961922
        //62467957194401269043877107275048102390895523597457
        //23189706772547915061505504953922979530901129967519
        //86188088225875314529584099251203829009407770775672
        //11306739708304724483816533873502340845647058077308
        //82959174767140363198008187129011875491310547126581
        //97623331044818386269515456334926366572897563400500
        //42846280183517070527831839425882145521227251250327
        //55121603546981200581762165212827652751691296897789
        //32238195734329339946437501907836945765883352399886
        //75506164965184775180738168837861091527357929701337
        //62177842752192623401942399639168044983993173312731
        //32924185707147349566916674687634660915035914677504
        //99518671430235219628894890102423325116913619626622
        //73267460800591547471830798392868535206946944540724
        //76841822524674417161514036427982273348055556214818
        //97142617910342598647204516893989422179826088076852
        //87783646182799346313767754307809363333018982642090
        //10848802521674670883215120185883543223812876952786
        //71329612474782464538636993009049310363619763878039
        //62184073572399794223406235393808339651327408011116
        //66627891981488087797941876876144230030984490851411
        //60661826293682836764744779239180335110989069790714
        //85786944089552990653640447425576083659976645795096
        //66024396409905389607120198219976047599490197230297
        //64913982680032973156037120041377903785566085089252
        //16730939319872750275468906903707539413042652315011
        //94809377245048795150954100921645863754710598436791
        //78639167021187492431995700641917969777599028300699
        //15368713711936614952811305876380278410754449733078
        //40789923115535562561142322423255033685442488917353
        //44889911501440648020369068063960672322193204149535
        //41503128880339536053299340368006977710650566631954
        //81234880673210146739058568557934581403627822703280
        //82616570773948327592232845941706525094512325230608
        //22918802058777319719839450180888072429661980811197
        //77158542502016545090413245809786882778948721859617
        //72107838435069186155435662884062257473692284509516
        //20849603980134001723930671666823555245252804609722
        //53503534226472524250874054075591789781264330331690
        
        return "[Implementation Pending]"
    }

    func solveProblem014() -> String {
        //Longest Collatz sequence
        //
        //The following iterative sequence is defined for the set of positive integers:
        //
        //n → n/2 (n is even)
        //n → 3n + 1 (n is odd)
        //
        //Using the rule above and starting with 13, we generate the following sequence:
        //
        //13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
        //It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
        //
        //Which starting number, under one million, produces the longest chain?
        //
        //NOTE: Once the chain starts the terms are allowed to go above one million.
        
        return "[Implementation Pending]"
    }

    func solveProblem015() -> String {
        //Lattice paths
        //
        //Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
        //
        //How many such routes are there through a 20×20 grid?
        
        return "[Implementation Pending]"
    }

    func solveProblem016() -> String {
        //Power digit sum
        //
        //215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
        //
        //What is the sum of the digits of the number 21000?

        return "[Implementation Pending]"
    }

    func solveProblem017() -> String {
        //Number letter counts
        //
        //If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
        //
        //If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
        //
        //NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.
        
        return "[Implementation Pending]"
    }

    func solveProblem018() -> String {
        //Maximum path sum I
        //
        //By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
        //
        //3
        //7 4
        //2 4 6
        //8 5 9 3
        //
        //That is, 3 + 7 + 4 + 9 = 23.
        //
        //Find the maximum total from top to bottom of the triangle below:
        //
        //75
        //95 64
        //17 47 82
        //18 35 87 10
        //20 04 82 47 65
        //19 01 23 75 03 34
        //88 02 77 73 07 63 67
        //99 65 04 28 06 16 70 92
        //41 41 26 56 83 40 80 70 33
        //41 48 72 33 47 32 37 16 94 29
        //53 71 44 65 25 43 91 52 97 51 14
        //70 11 33 28 77 73 17 78 39 68 17 57
        //91 71 52 38 17 14 91 43 58 50 27 29 48
        //63 66 04 68 89 53 67 30 73 16 69 87 40 31
        //04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
        //
        //NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)
        
        
        return "[Implementation Pending]"
    }

    func solveProblem019() -> String {
        //Counting Sundays
        //
        //You are given the following information, but you may prefer to do some research for yourself.
        //
        //1 Jan 1900 was a Monday.
        //Thirty days has September,
        //April, June and November.
        //All the rest have thirty-one,
        //Saving February alone,
        //Which has twenty-eight, rain or shine.
        //And on leap years, twenty-nine.
        //A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
        //
        //How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
        
        return "[Implementation Pending]"
    }

    func solveProblem020() -> String {
        //Factorial digit sum
        //
        //n! means n × (n − 1) × ... × 3 × 2 × 1
        //For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
        //and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
        //Find the sum of the digits in the number 100!
        
        return "[Implementation Pending]"
    }

    // MARK: Convenience methods
    
    func formattedNumberString(number: Int) -> String {
        let numberFormatter = NSNumberFormatter()
        numberFormatter.numberStyle = NSNumberFormatterStyle.DecimalStyle
        numberFormatter.maximumFractionDigits = 0

        let formattedResult = numberFormatter.stringFromNumber(NSNumber(integer: number))!
        return formattedResult
    }
    
    func productOfDigitsOfNumber(number: Int) -> Int {
        
        var fourDigitNum:Int = number
        var product:Int = 1
        
        while (fourDigitNum != 0) {
            let digit:Int = fourDigitNum % 10
            product *= digit
            
            fourDigitNum /= 10
        }
        
        return product
    }

    func isPrime(number: Int) -> Bool {
        
        // Both 0 and 1 are not prime (by definition)
        if (number <= 0 || number == 1) {
            return false
        }
        
        if (number == 2 || number == 3) {
            return true
        }
        
        if (number % 2 == 0 || number % 3 == 0) {
            return false
        }
        
        let num:Double = Double(number)
        
        // Loop to check if the number is prime
        var divisor: Double = 0
        var numberSqrt: Double = sqrt(num)
        
        for divisor=5; divisor<=numberSqrt; divisor+=2 {
            
            if (num % divisor == 0) {
                return false
            }
        }
        
        return true
    }
    
    func isPalindrome(input: String) -> Bool {
        var p: Bool = true
        var numberOfDigits: Int
        var count: Int
        var index: Int = 0
        
        var c1: Character
        var c2: Character
        
        numberOfDigits = countElements(input)
        
        // Index is used to traverse string from start, Count is used to traverse string from end
        count = numberOfDigits-1
        index = 0
        
        while (index < count) {
            c1 = input[advance(input.startIndex, index)]
            c2 = input[advance(input.startIndex, count)]
            
            // Comparing characters at start and end index to verify palindrome number
            if (c1 == c2) {
                index++
                count--
                
            } else {
                p = false
                break
            }
        }
        
        return p
    }
    
    // MARK: Deprecated
    
    func isPrime__deprecated_2015_03_10(number: Int) -> Bool {
        
        // Both 0 and 1 are not prime (by definition)
        if (number <= 0 || number == 1) {
            return false
        }
        
        // Loop to check if the number is prime
        var divisor: Int = 0
        var numberHalf: Int = (number/2)
        
        for divisor=2; divisor<numberHalf; divisor++ {
            
            if (number % divisor == 0) {
                return false
            }
        }
        
        return true
    }
}
